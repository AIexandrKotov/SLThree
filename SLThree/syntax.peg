@namespace SLThree
@classname Parser
@using System.Linq;
@using System.Globalization;
@using SLThree.Extensions;

file <BaseStatement> 
    = "#SLT#" _ v:statement_list _ EOF { v }
    / "#EXPR#" _ expr:expression _ EOF { new ExpressionStatement(expr, state) }

statement_list <StatementListStatement>
    = st:statement<0,,_> { new StatementListStatement(st, state) }

statement <BaseStatement>
    = return_statement
    / break_statement
    / continue_statement
    / using_statement
    / context_statement
    / condition_statement
    / switch_statement
    / foreach_statement
    / while_statement
    / try_statement
    / throw_statement
    / expression_statement
    / block_statement
    / ";" { new StatementListStatement(new BaseStatement[0], state) }

using_statement <UsingStatement>
    = "using" _required_ u:using  
    using_alias:(<NameExpression> _required_ "as" _required_ n:name {n})?
    _ ";" {
        new UsingStatement(GetOptional(using_alias), u, state)
    }

return_statement <ReturnStatement>
    = "return" _ expr:expression _ ";" { new ReturnStatement(expr, state) }
    / "return" _ ";" { new ReturnStatement(state) }
    / "return" (_ expr:expression)? _ { Panic<ReturnStatement>(new SyntaxError("Expected `;`", state)) }

break_statement <BreakStatement>
    = "break" _ ";" { new BreakStatement(state) }
    / "break" _ { Panic<BreakStatement>(new SyntaxError("Expected `;`", state)) }

continue_statement <ContinueStatement>
    = "continue" _ ";" { new ContinueStatement(state) }
    / "continue" _ { Panic<ContinueStatement>(new SyntaxError("Expected `;`", state)) }

switch_statement <SwitchStatement>
    = "switch" _ "(" _ expr:expression _ ")" _ "{" _ st:case_node* _ "}" { new SwitchStatement(expr, st, state) }

case_node <SwitchStatement.Node>
    = "case" _ expr:expression _ ":" _ st:statement _ { new SwitchStatement.Node(expr, st, false) }
    / "case" _ expr:expression _ ":" _ { new SwitchStatement.Node(expr, null, true) }

block_statement <StatementListStatement>
    = "{" _ st:statement_list _ "}" { st }
    / "{" _ st:statement_list _ { Panic<StatementListStatement>(new SyntaxError("Unclosed block", state)) }

while_statement <WhileLoopStatement>
    = "while" _ "(" _ cond:expression _ ")" _ body:statement { new WhileLoopStatement(cond, GetListStatement(body), state) }
    / "while" _ "(" _ ")" _ statement? { Panic<WhileLoopStatement>(new SyntaxError("Empty loop head", state)) }
    / "while" _ cond:expression { Panic<WhileLoopStatement>(new SyntaxError("Loop head must be in ( )", state)) }

foreach_statement <ForeachLoopStatement>
    = "foreach" _ "(" _ n:expression _ "in" _ iter:expression _ ")" _ body:statement { new ForeachLoopStatement(n, iter, GetStatements(body), state) }
    / "foreach" _ "(" _ n:expression _ "in" _ iter:expression _ ")" _ statement? { Panic<ForeachLoopStatement>(new SyntaxError("Foreach body must be in { }", state)) }
    / "foreach" _ "(" _ n:expression _ ")" _ statement? { Panic<ForeachLoopStatement>(new SyntaxError("Foreach head must be like `x in y`", state)) }
    / "foreach" _ "(" _ ")" _ statement? { Panic<ForeachLoopStatement>(new SyntaxError("Empty loop head", state)) }
    / "foreach" _ cond:expression { Panic<ForeachLoopStatement>(new SyntaxError("Loop head must be in ( )", state)) }

condition_statement <ConditionStatement>
    = "if" _ "(" _ cond:expression _ ")" _ t:statement _ "else" _ f:statement { new ConditionStatement(cond, GetListStatement(t), GetListStatement(f), state) }
    / "if" _ "(" _ cond:expression _ ")" _ t:statement { new ConditionStatement(cond, GetListStatement(t), new StatementListStatement(new BaseStatement[0], state), state) }
    / "if" _ "(" _ ")" _ statement? { Panic<ConditionStatement>(new SyntaxError("Empty condition", state)) }

try_statement <TryStatement>
    = "try" _ try_body:block_statement _ 
      "catch" _ "(" _ catch_var:expression _ ")" _ catch_body:statement _
      "finally" _ finally_body:block_statement                                  { new TryStatement(try_body, catch_var, GetListStatement(catch_body), finally_body, state) }
    / "try" _ try_body:block_statement _ 
      "catch" _ catch_body:block_statement _
      "finally" _ finally_body:block_statement                                  { new TryStatement(try_body, null     , catch_body, finally_body, state) }
    / "try" _ try_body:block_statement _ 
      "catch" _ "(" _ catch_var:expression _ ")" _ catch_body:statement         { new TryStatement(try_body, catch_var, GetListStatement(catch_body), null        , state) }
    / "try" _ try_body:block_statement _ 
      "catch" _ catch_body:block_statement                                      { new TryStatement(try_body, null     , catch_body, null        , state) }
    / "try" _ try_body:block_statement _ 
      "finally" _ finally_body:block_statement                                  { new TryStatement(try_body, null     , null      , finally_body, state) }
    / "try" _ try_body:block_statement                                          { new TryStatement(try_body, null     , null      , null        , state) }

throw_statement <ThrowStatement>
    = "throw" _required_ expr:expression _ ";" { new ThrowStatement(expr, state) }
    / "throw" _required_ expr:expression _ { Panic<ThrowStatement>(new SyntaxError("Expected `;`", state)) }

context_statement <ContextStatement>
    = "context" c:context { new ContextStatement(c, state) }

expression_statement <ExpressionStatement> 
    = value:expression _ ";" { new ExpressionStatement(value, state) }
    / expression _ { Panic<ExpressionStatement>(new SyntaxError("Expected `;`", state)) }

expression <BaseExpression>
    = binary_9

binary_9 <BaseExpression> -memoize
    = left:keyword _ ("=" / "+=" / "-=" / "*=" / "/=" / "%=" / "&=" / "|=" / "^=") _ right:binary_9 { Panic<BaseExpression>(new SyntaxError("Keywords is not a valid name", state)) }
    / method
    / left:binary_9 _ "|>" _ right:binary_7 { InjectFirst(left, right) }
    / "?" _ "=" _ right:binary_9 { new BinaryAssignUnknown(right, state) }
    / left:arg_name _ "=" _ right:binary_9 { new BinaryAssign(left, right, state) }
    / left:binary_7 _ "=" _ right:binary_9 { new BinaryAssign(left, right, state) }
    / left:binary_7 _ "+=" _ right:binary_9 { new BinaryAssign(left, new BinaryAdd(left, right, state), state) }
    / left:binary_7 _ "-=" _ right:binary_9 { new BinaryAssign(left, new BinaryRem(left, right, state), state) }
    / left:binary_7 _ "*=" _ right:binary_9 { new BinaryAssign(left, new BinaryMultiply(left, right, state), state) }
    / left:binary_7 _ "/=" _ right:binary_9 { new BinaryAssign(left, new BinaryDivide(left, right, state), state) }
    / left:binary_7 _ "%=" _ right:binary_9 { new BinaryAssign(left, new BinaryMod(left, right, state), state) }
    / left:binary_7 _ "&=" _ right:binary_9 { new BinaryAssign(left, new BinaryBitAnd(left, right, state), state) }
    / left:binary_7 _ "|=" _ right:binary_9 { new BinaryAssign(left, new BinaryBitOr(left, right, state), state) }
    / left:binary_7 _ "^=" _ right:binary_9 { new BinaryAssign(left, new BinaryBitXor(left, right, state), state) }
    / ternary_0

method <BaseExpression> =
    lambda
    
ternary_0 <BaseExpression> -memoize
    = cond:ternary_0 _ "?" _ t:expression _ ":" _ f:expression { new TernaryOperator(cond, t, f, state) }
    / binary_8

binary_8 <BaseExpression> -memoize
    = lower:binary_8 _ ".." _ upper:binary_8 { new CreatorRange(lower, upper, state) }
    / null_coalescing

null_coalescing <BaseExpression>
    = left:binary_7 _ "-?" _ right:null_coalescing { new SafeExpression(left, right, state) }
    / left:binary_7 _ "??" _ right:null_coalescing { new NullCoalescing(left, right, state) }
    / binary_7

binary_7 <BaseExpression> -memoize
    = left:binary_7 _ "||" _ right:binary_6 { new BinaryOr(left, right, state) }
    / binary_6

binary_6 <BaseExpression> -memoize
    = left:binary_6 _ "&&" _ right:binary_5 { new BinaryAnd(left, right, state) }
    / binary_5

binary_5 <BaseExpression> -memoize
    = left:binary_5 _ "&" _ right:binary_4 { new BinaryBitAnd(left, right, state) }
    / left:binary_5 _ "^" _ right:binary_4 { new BinaryBitXor(left, right, state) }
    / left:binary_5 _ "|" _ right:binary_4 { new BinaryBitOr(left, right, state) }
    / binary_4

binary_4 <BaseExpression> -memoize
    = left:binary_4 _ "==" _ right:binary_3 { new BinaryEquals(left, right, state) }
    / left:binary_4 _ "!=" _ right:binary_3 { new BinaryUnequals(left, right, state) }
    / left:binary_4 _ "is" _required_ right:typename { new BinaryIs(left, right, state) }
    / binary_3

binary_3 <BaseExpression> -memoize
    = left:binary_3 _ ">=" _ right:binary_2 { new BinaryGreaterThanEquals(left, right, state) }
    / left:binary_3 _ "<=" _ right:binary_2 { new BinaryLessThanEquals(left, right, state) }
    / left:binary_3 _ ">" _ right:binary_2 { new BinaryGreaterThan(left, right, state) }
    / left:binary_3 _ "<" _ right:binary_2 { new BinaryLessThan(left, right, state) }
    / binary_2

binary_2 <BaseExpression> -memoize
    = left:binary_2 _ "+" _ right:binary_1 { new BinaryAdd(left, right, state) }
    / left:binary_2 _ "-" _ right:binary_1 { new BinaryRem(left, right, state) }
    / binary_1

binary_1 <BaseExpression> -memoize
    = left:binary_1 _ "*" _ right:binary_0 { new BinaryMultiply(left, right, state) }
    / left:binary_1 _ "/" _ right:binary_0 { new BinaryDivide(left, right, state) }
    / left:binary_1 _ "%" _ right:binary_0 { new BinaryMod(left, right, state) }
    / binary_0

binary_0 <BaseExpression> -memoize
    = left:binary_0 _ "as" _required_ right:typename { new CastExpression(left, right, state) }
    / left:binary_0 _ "::" _ right:name 
    _ gen_args:(<IList<TypenameExpression>> "<" _ gen_args_i:typename<0,,"," _> _ ">" {gen_args_i})? 
    _ args:    (<IList<TypenameExpression>> "(" _ args_i    :typename<0,,"," _> _ ")" {args_i    })? {
        new ReflectionExpression(left, right, GetOptional(gen_args)?.ToArray(), GetOptional(args)?.ToArray(), state)
    }
    / left:binary_min { left }

binary_min <BaseExpression>
    = unary

unary <BaseExpression>
    = "+" _ left:binary_min { new UnaryAdd(left, state) }
    / i8:("-" _ ([0-9_]+ ("i8"))) { new SByteLiteral(sbyte.Parse(i8.Replace("i8", "").Replace("_", ""), CultureInfo.InvariantCulture), i8, state) }
    / i16:("-" _ ([0-9_]+ ("i16"))) { new ShortLiteral(short.Parse(i16.Replace("i16", "").Replace("_", ""), CultureInfo.InvariantCulture), i16, state) }
    / i32:("-" _ ([0-9_]+ ("i32"))) { new IntLiteral(int.Parse(i32.Replace("i32", "").Replace("_", ""), CultureInfo.InvariantCulture), i32, state) }
    / i64:("-" _ ([0-9_]+ ("i64"))) { new LongLiteral(long.Parse(i64.Replace("i64", "").Replace("_", ""), CultureInfo.InvariantCulture), i64, state) }
    / "-" _ left:binary_min { new UnaryRem(left, state) }
    / "~" _ left:binary_min { new UnaryBitNot(left, state) }
    / "!" _ left:binary_min { new UnaryNot(left, state) }
    / "^" _ left:binary_min { new UnaryChoose(left, state) }
    / "*" _ "<" _ arg:typename _ ">" _ left:binary_min { new UnaryGetChooser(left, arg, state) }
    / "*" _ left:binary_min { new UnaryGetChooser(left, null, state) }
    / "@@" _ left:typename { new UnaryStaticReflection(left, state) }
    / "@" _ left:typename { new UnaryReflection(left, state) }
    / primary

primary <BaseExpression> -memoize
    = left:primary _ conditional:"?"? _ "(" _ args:expression<0,,"," _> _ ")" { new InvokeExpression(left, args.ToArray(), conditional.Count == 1, state) }
    / left:primary _ conditional:"?"? _ "[" _ args:expression<1,,"," _> _ "]" { new IndexExpression(left, args.ToArray(), conditional.Count == 1, state) }
    / left:primary _ conditional:"?"? _ "." _ right:access_right { new MemberAccess(left, right, conditional.Count == 1, state) }
    / "(" _ x:expression _ ")" { x.RaisePriority() }
    / "{" _ etrs:(<CreatorDictionary.Entry>left:expression _ ":" _ right:expression { new CreatorDictionary.Entry(left, right, state) })
        <0,,"," _> _ ("," _ )? "}" {
            new CreatorDictionary(etrs.ToArray(), state)
    }
    / "new" _required_ "context" c: context { c }
    / "new" _required_ "using" _required_ u: using { u }
    / "new" _required_ right:typename _ "(" _ args:expression<0,,"," _> _ ")" { new NewExpression(right, args.ToArray(), state) }
    / "new" _required_ tp:typename _ "[" _ size:expression _ "]" { new CreatorArray(tp, size, state) }
    / "(" _ args:arg_name<1,,"," _> _ ("," _ )? ")" { new CreatorTuple(args.ToArray(), state) }
    / "(" _ args:expression<1,,"," _> _ ("," _ )? ")" { new CreatorTuple(args.ToArray(), state) }
    / "[" _ args:expression<0,,"," _> _ ("," _ )? "]" { new CreatorList(args.ToArray(), state) }
    / name_literal
    / special
    / name
    / literal
    / "[" _ x:expression { Panic<BaseExpression>(new SyntaxError("Unclosed brackets", state)) }
    / "(" _ x:expression { Panic<BaseExpression>(new SyntaxError("Unclosed brackets", state)) }

access_right <BaseExpression> -memoize
    = left:name _ "(" _ args:expression<0,,"," _> _ ")" { new InvokeExpression(left, args.ToArray(), state) }
    / right:access_right { right }
    / right:name { right }

using <CreatorUsing>
    = t_name:typename { new CreatorUsing(t_name, state) }

context <CreatorContext>
    = context_name:(<NameExpression> _required_ n:name {n})?
    context_type:(<TypenameExpression> _ ":" _ t:typename {t})?
    context_body:(<StatementListStatement> _ st:block_statement {st})? {
        new CreatorContext(
            GetOptional(context_name),
            GetOptional(context_type), 
            GetOptional(context_body)?.Statements.ToArray().ConvertAll(x => CheckOnContextStatements(x)) ?? new BaseStatement[0],
            state)
    }

lambda <BaseExpression>
    = left:(
        <ValueTuple<IList<string>, NameExpression[], TypenameExpression>>
        mods:(<IList<string>> mods_i:method_modificator<1,,_required_> _required_ { mods_i })?
        args:(
            <IList<NameExpression>> "(" _ args_i:arg_name<0,,"," _> _ ")" { args_i }
            / a:arg_name { new NameExpression[1] { a } }
        )
        ret:(<TypenameExpression> _ ":" _ t:typename {t})? {
            new ValueTuple<IList<string>, NameExpression[], TypenameExpression>(GetOptional(mods) ?? new string[0], args.ToArray(), GetOptional(ret))
        }
    ) _ "=>" _ right:(
        <StatementListStatement>
        expr:expression { GetListStatement(new ReturnStatement(expr, state)) }
        / block_statement
    ) {
        new LambdaExpression(new InvokeExpression(null, left.Item2, state), right, left.Item3, left.Item1, state)
    }

method_modificator
    = "recursive"
    / "implicit"

typename <TypenameExpression>
    = t_node:typename_node _ "<" _ t_list:typename<1,,"," _> _ ">" { new TypenameExpression(t_node, t_list.ToArray(), state) }
    / t_node:typename_node { new TypenameExpression(t_node, state) }

typename_node <BaseExpression> -memoize
    = left:typename_node _ "." _ right:name { new MemberAccess(left, right, state) }
    / special
    / name

arg_name <NameExpression>
    = t:typename _ n:name { n.Hint(t) }
    / name

name_literal <BaseExpression>
    = b:("true"/"false") { new BoolLiteral(bool.Parse(b), state) }
    / "null" { new NullLiteral(state) }

special <BaseExpression>
    = "global" { new GlobalLiteral(state) }
    / "super" { new SuperLiteral(state) }
    / "upper" { new UpperLiteral(state) }
    / "this" { new ThisLiteral(state) }
    / "self" { new SelfLiteral(state) }

literal <BaseExpression>
    = percent_literal
    / float_literal

    / binary_num_literal
    / octal_num_literal
    / hex_num_literal
    / num_literal

    / interpolated_string
    / string_literal
    / char_literal

percent_literal <DoubleLiteral>
    = f64:([0-9_]+ ("."[0-9_]+)? "%") { new DoubleLiteral(double.Parse(f64.Replace("f64", "").Replace("_", "").Replace("%", ""), CultureInfo.InvariantCulture) / 100.0, f64, state) }

float_literal <BaseExpression>
    = f32:([0-9_]+ ("." [0-9_]+)? ("f32"))    { new FloatLiteral(float.Parse(f32.Replace("f32", "").Replace("_", ""), CultureInfo.InvariantCulture), f32, state) }
    / f64:([0-9_]+ ("." [0-9_]+) ("f64")?)    { new DoubleLiteral(double.Parse(f64.Replace("f64", "").Replace("_", ""), CultureInfo.InvariantCulture), f64, state) }
    / f64:([0-9_]+ ("f64"))                  { new DoubleLiteral(double.Parse(f64.Replace("f64", "").Replace("_", ""), CultureInfo.InvariantCulture), f64, state) }

binary_num_literal <BaseExpression>
    = "0b" i8:([01_]+ ("i8"))       { new SByteLiteral  (Convert.ToSByte    (i8.Replace("i8", "").Replace("_", ""), 2), "0b"+i8, state) }
    / "0b" u8:([01_]+ ("u8"))       { new ByteLiteral   (Convert.ToByte     (u8.Replace("u8", "").Replace("_", ""), 2), "0b"+u8, state) }
    / "0b" i16:([01_]+ ("i16"))     { new ShortLiteral  (Convert.ToInt16    (i16.Replace("i16", "").Replace("_", ""), 2), "0b"+i16, state) }
    / "0b" u16:([01_]+ ("u16"))     { new UShortLiteral (Convert.ToUInt16   (u16.Replace("u16", "").Replace("_", ""), 2), "0b"+u16, state) }
    / "0b" i32:([01_]+ ("i32"))     { new IntLiteral    (Convert.ToInt32    (i32.Replace("i32", "").Replace("_", ""), 2), "0b"+i32, state) }
    / "0b" u32:([01_]+ ("u32"))     { new UIntLiteral   (Convert.ToUInt32   (u32.Replace("u32", "").Replace("_", ""), 2), "0b"+u32, state) }
    / "0b" u64:([01_]+ ("u64"))     { new ULongLiteral  (Convert.ToUInt64   (u64.Replace("u64", "").Replace("_", ""), 2), "0b"+u64, state) }
    / "0b" i64:([01_]+ ("i64")?)    { new LongLiteral   (Convert.ToInt64    (i64.Replace("i64", "").Replace("_", ""), 2), "0b"+i64, state) }
    / "0b" .* { Panic<BaseExpression>(new SyntaxError("Wrong binary literal", state)) }

octal_num_literal <BaseExpression>
    = "0o" i8:([0-7_]+ ("i8"))       { new SByteLiteral  (Convert.ToSByte    (i8.Replace("i8", "").Replace("_", ""), 8), "0o"+i8, state) }
    / "0o" u8:([0-7_]+ ("u8"))       { new ByteLiteral   (Convert.ToByte     (u8.Replace("u8", "").Replace("_", ""), 8), "0o"+u8, state) }
    / "0o" i16:([0-7_]+ ("i16"))     { new ShortLiteral  (Convert.ToInt16    (i16.Replace("i16", "").Replace("_", ""), 8), "0o"+i16, state) }
    / "0o" u16:([0-7_]+ ("u16"))     { new UShortLiteral (Convert.ToUInt16   (u16.Replace("u16", "").Replace("_", ""), 8), "0o"+u16, state) }
    / "0o" i32:([0-7_]+ ("i32"))     { new IntLiteral    (Convert.ToInt32    (i32.Replace("i32", "").Replace("_", ""), 8), "0o"+i32, state) }
    / "0o" u32:([0-7_]+ ("u32"))     { new UIntLiteral   (Convert.ToUInt32   (u32.Replace("u32", "").Replace("_", ""), 8), "0o"+u32, state) }
    / "0o" u64:([0-7_]+ ("u64"))     { new ULongLiteral  (Convert.ToUInt64   (u64.Replace("u64", "").Replace("_", ""), 8), "0o"+u64, state) }
    / "0o" i64:([0-7_]+ ("i64")?)    { new LongLiteral   (Convert.ToInt64    (i64.Replace("i64", "").Replace("_", ""), 8), "0o"+i64, state) }
    / "0o" .* { Panic<BaseExpression>(new SyntaxError("Wrong octal const", state)) }

hex_num_literal <BaseExpression>
    = "0x" i8:([0-9A-Fa-f_]+ ("i8"))       { new SByteLiteral  (Convert.ToSByte    (i8.Replace("i8", "").Replace("_", ""), 16), "0x"+i8, state) }
    / "0x" u8:([0-9A-Fa-f_]+ ("u8"))       { new ByteLiteral   (Convert.ToByte     (u8.Replace("u8", "").Replace("_", ""), 16), "0x"+u8, state) }
    / "0x" i16:([0-9A-Fa-f_]+ ("i16"))     { new ShortLiteral  (Convert.ToInt16    (i16.Replace("i16", "").Replace("_", ""), 16), "0x"+i16, state) }
    / "0x" u16:([0-9A-Fa-f_]+ ("u16"))     { new UShortLiteral (Convert.ToUInt16   (u16.Replace("u16", "").Replace("_", ""), 16), "0x"+u16, state) }
    / "0x" i32:([0-9A-Fa-f_]+ ("i32"))     { new IntLiteral    (Convert.ToInt32    (i32.Replace("i32", "").Replace("_", ""), 16), "0x"+i32, state) }
    / "0x" u32:([0-9A-Fa-f_]+ ("u32"))     { new UIntLiteral   (Convert.ToUInt32   (u32.Replace("u32", "").Replace("_", ""), 16), "0x"+u32, state) }
    / "0x" u64:([0-9A-Fa-f_]+ ("u64"))     { new ULongLiteral  (Convert.ToUInt64   (u64.Replace("u64", "").Replace("_", ""), 16), "0x"+u64, state) }
    / "0x" i64:([0-9A-Fa-f_]+ ("i64")?)    { new LongLiteral   (Convert.ToInt64    (i64.Replace("i64", "").Replace("_", ""), 16), "0x"+i64, state) }
    / "0x" .* { Panic<BaseExpression>(new SyntaxError("Wrong hexadecimal literal", state)) }

num_literal <BaseExpression>
    = i8:([0-9_]+ ("i8"))       { new SByteLiteral  (sbyte.Parse    (i8.Replace("i8", "").Replace("_", ""), CultureInfo.InvariantCulture), i8, state) }
    / u8:([0-9_]+ ("u8"))       { new ByteLiteral   (byte.Parse     (u8.Replace("u8", "").Replace("_", ""), CultureInfo.InvariantCulture), u8, state) }
    / i16:([0-9_]+ ("i16"))     { new ShortLiteral  (short.Parse    (i16.Replace("i16", "").Replace("_", ""), CultureInfo.InvariantCulture), i16, state) }
    / u16:([0-9_]+ ("u16"))     { new UShortLiteral (ushort.Parse   (u16.Replace("u16", "").Replace("_", ""), CultureInfo.InvariantCulture), u16, state) }
    / i32:([0-9_]+ ("i32"))     { new IntLiteral    (int.Parse      (i32.Replace("i32", "").Replace("_", ""), CultureInfo.InvariantCulture), i32, state) }
    / u32:([0-9_]+ ("u32"))     { new UIntLiteral   (uint.Parse     (u32.Replace("u32", "").Replace("_", ""), CultureInfo.InvariantCulture), u32, state) }
    / u64:([0-9_]+ ("u64"))     { new ULongLiteral  (ulong.Parse    (u64.Replace("u64", "").Replace("_", ""), CultureInfo.InvariantCulture), u64, state) }
    / i64:([0-9_]+ ("i64")?)    { new LongLiteral   (long.Parse     (i64.Replace("i64", "").Replace("_", ""), CultureInfo.InvariantCulture), i64, state) }
    
keyword
    = "while" / "if" / "else" / "foreach" / "return" / "break" / "continue" 
    / "using" / "context" / "new"
    / "self" / "upper" / "this" / "global" / "super"
    / "try" / "catch" / "finally" / "throw"

name <NameExpression>
    = u:unicode {
        new NameExpression(u, state)
    }

unicode
    = name_not_digit name_digit*

name_digit
    = first:.&{ first == "_" || char.IsLetter(first[0]) || char.IsDigit(first[0]) }

name_not_digit
    = first:.&{ first == "_" || char.IsLetter(first[0]) }

interpolated_string <InterpolatedString> = "$\"" chars:interpolated_start exp:interpolated_expression* ("\"" / #ERROR{ "Expected '\"'" }) {
    new InterpolatedString(chars, exp, state)
}

interpolated_expression <ValueTuple<BaseExpression, string>> = ("{" expr:interpolation "}" s:interpolated_mid?) { new ValueTuple<BaseExpression, string>(expr, s.JoinIntoString("")) }

interpolated_start = chars:interpolated_mid? { chars.JoinIntoString("") }

interpolated_mid = chars:interpolated_element+ { chars.JoinIntoString("") }

interpolated_element
    = interpolation_escape
    / string_escape
    / [^\\\t\r\n\"{}]

interpolation_escape
    = "{{" { "{{" }
    / "}}" { "}}" }

interpolation
    = expression

string_literal <StringLiteral> = "\"" chars:string_element* ("\"" / #ERROR{ "Expected '\"'" }) {
    new StringLiteral(string.Concat(chars), state)
}

char_literal <CharLiteral>
    = "'" c:char_element "'" { new CharLiteral(c[0], state) }

char_element
    = char_escape
    / string_element

char_escape
    = "\\\\'" { "'" }

string_element
    = string_escape
    / [^\\\t\r\n\"]

string_escape
    = "\\\\" { "\\" }
    / "\\t" { "\t" }
    / "\\n" { "\n" }
    / "\\r" { "\r" }
    / "\\\"" { "\"" }

comment
    = "//" ([^\r\n]*)

_required_
    = [ \t\r\n] _ { " " }

_
    = [ \t\r\n]* (comment+ _)? { "" }

EOF = !. / comment / c:. { Panic<string>(new UnexpectedError(c[0], state)) }
